# Machshevet (Peg Solitaire) Solver & Analytics üß†

> **A high-performance Hybrid-BFS Oracle comprising ~1.6 million unique winning states.**

This project implements an optimized solver and analysis tool for the classic **Peg Solitaire (Standard English Board)**. It features a real-time "Survival Funnel" dashboard that visualizes the exact number of winning paths available to the player at any given moment.

![Python](https://img.shields.io/badge/Python-3.10%2B-blue)
![Algorithm](https://img.shields.io/badge/Algorithm-Hybrid_Forward_Backward_BFS-purple)
![Acceleration](https://img.shields.io/badge/Acceleration-Numba_JIT-orange)
![State Space](https://img.shields.io/badge/Winning_States-~1.6M_Canonical-success)

## üöÄ The Algorithmic Journey

This repository documents a journey of optimization, moving from complex Reinforcement Learning attempts to precise mathematical graph theory and High-Performance Computing (HPC).

### Phase 1: The AI Attempt (Deprecated)
Initially, we implemented **AlphaZero** (Deep Reinforcement Learning with MCTS) and PBRS (Potential-Based Reward Shaping) using "Pagoda functions."
* **The Reality:** For a deterministic puzzle with a finite state space (~33 bits), Neural Networks were overkill. The reward signal in Peg Solitaire is extremely sparse (you only win at the very end), making efficient training incredibly difficult despite complex reward shaping.
* **Outcome:** The complexity was high, and convergence was slow or non-existent. These attempts are archived in `WontWork/`.

### Phase 2: Reverse BFS (Inefficient)
We switched to a **Reverse BFS** approach‚Äîstarting from the single winning peg and working backwards to find all possible winning configurations.
* **The Problem:** The algorithm found millions of "solvable" states that were actually unreachable from a standard starting board. It mapped the "Universal Solvable Space" rather than the specific game graph.
* **Performance:** Python-based implementations (`solver.py`, `solver_WithTarget.py`) were logically correct but extremely slow, taking hours to execute due to the massive state space and Python's interpreter overhead.

### Phase 3: The Hybrid HPC Solution (Current) ‚úÖ
To solve the game efficiently and exactly, we implemented a **Hybrid Forward-Pruned Reverse Solver** accelerated with **Numba**:

1.  **Forward Pass (Reachability):** We map the entire "Reachable Universe" starting from the standard board.
    * *Result:* ~23.5 Million unique states reachable from the start.
2.  **Backward Pass (Winning Paths):** We perform a Reverse BFS from the winning state, but **only keep states that exist in the Reachable Universe**.
    * *Result:* The database is pruned down to exactly **~1,679,072** valid, canonical winning states.
3.  **Hardware Acceleration:** All bitwise operations and symmetry reductions are compiled to machine code using `numba.njit`.

## üõ†Ô∏è Technical Architecture

The engine runs purely on the CPU using highly optimized techniques:

* **Bitboards:** The board is represented as a single 64-bit integer. Move validation and application are $O(1)$ bitwise operations.
* **Symmetry Pruning (D4 Group):** Every board state is normalized to its "Canonical Form" (minimum integer value of 8 rotations/reflections), drastically reducing the memory footprint.
* **Hybrid Logic:** By intersecting the "Reachable Set" with the "Reverse Search," we eliminate mathematically impossible configurations.
* **JIT Compilation:** The core solver (`Solver_Numba.py`) uses Numba to bypass Python's Global Interpreter Lock (GIL) and overhead, achieving C-level performance.

## üìâ The "Survival Funnel"

The GUI features a unique analytics graph:
* **Start:** Shows the total number of winning paths (Survival Score).
* **Mid-Game:** The graph creates a "funnel" shape as the decision space narrows.
* **Dead End:** If the player makes a fatal mistake, the graph flatlines to **Zero** instantly, providing immediate feedback even before the game is physically over.

## üìÇ Repository Structure

### ‚ö° Production Engine
* **`Solver_Numba.py` (The Solution)**
    * The highly optimized generator script.
    * Uses `numba` to generate the complete `solitaire_lookup_table.pkl` database (~1.6M states) in **under 3 minutes**.
* **`solver.py`**
    * The main GUI application (Tkinter).
    * Loads the brain file generated by `Solver_Numba.py` to provide real-time analytics.
    * *Note:* Contains a slower, pure-Python implementation of the training logic as a fallback/reference.

### üß™ Research & Deprecated (`WontWork/`)
Archived attempts at solving the game using Deep Learning and pure Python BFS.
* **`MCTS.py`, `NET.py`, `V2_51.py`**: AlphaZero/GNN implementations.
* **`solver_WithTarget.py`**: A pure Python implementation of the hybrid logic (correct but slow).

## ‚ö° Performance Benchmarks

| Metric | Pure Python BFS (`solver.py`) | **Numba Hybrid (`Solver_Numba.py`)** |
| :--- | :--- | :--- |
| **Total Reachable States** | ~23,475,688 | **~23,475,688** |
| **Final Winning States** | ~1,679,072 | **1,679,072** |
| **Execution Time** | Hours (Never Finished) | **~160 Seconds** |
| **Logic** | Valid | **Valid & Optimized** |

## üéÆ How to Run

1.  **Clone the repository:**
    ```bash
    git clone [https://github.com/your-username/machshevet-solver.git](https://github.com/your-username/machshevet-solver.git)
    cd machshevet-solver
    ```

2.  **Install Dependencies:**
    ```bash
    pip install numpy numba
    ```

3.  **Generate the Brain (One-time setup):**
    Run the Numba optimizer to generate the lookup table.
    ```bash
    python Solver_Numba.py
    ```
    *Output: `solitaire_lookup_table.pkl`*

4.  **Run the Game:**
    Ensure the generated `.pkl` file is in the same directory (rename it to `solitaire_pro_brain.pkl` if the GUI expects that name, or update the GUI code).
    ```bash
    python solver.py
    ```

5.  **Controls:**
    * **Left Click:** Move peg.
    * **Auto Solve:** Watch the AI execute a perfect solution from your current state.
    * **Undo:** Revert move (visualize how the "Funnel" recovers).

---
**Author:** Yarden Viktor Dejorno
